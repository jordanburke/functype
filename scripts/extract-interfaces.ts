#!/usr/bin/env npx tsx
/**
 * Extracts full TypeScript interface definitions with JSDoc comments from source files.
 * Generates src/cli/full-interfaces.ts for the --full flag.
 */

import * as fs from "fs"
import * as path from "path"

interface InterfaceInfo {
  name: string
  sourceFile: string
  fullText: string
}

// Map of type names to their source files and extraction info
interface TypeSource {
  file: string
  extractName?: string // Name to extract if different from key
  isType?: boolean // True if it's a type alias instead of interface
}

const TYPE_SOURCES: Record<string, TypeSource> = {
  Option: { file: "src/option/Option.ts" },
  Either: { file: "src/either/Either.ts" },
  Try: { file: "src/try/Try.ts" },
  List: { file: "src/list/List.ts" },
  Set: { file: "src/set/Set.ts" },
  Map: { file: "src/map/Map.ts" },
  Lazy: { file: "src/lazy/Lazy.ts" },
  LazyList: { file: "src/list/LazyList.ts" },
  TaskOutcome: { file: "src/core/task/Task.ts" },
  FPromise: { file: "src/fpromise/FPromise.ts", isType: true },
  Tuple: { file: "src/tuple/Tuple.ts" },
  Stack: { file: "src/stack/Stack.ts", isType: true },
}

/**
 * Extracts an interface or type definition with its JSDoc from source text.
 * Looks for: JSDoc comment followed by "export interface Name<..." or "export type Name<..."
 */
function extractDefinition(sourceText: string, name: string, isType: boolean = false): string | null {
  const keyword = isType ? "type" : "interface"
  const lines = sourceText.split("\n")

  let inDefinition = false
  let braceCount = 0
  let hasSeenOpenBrace = false
  let jsDocStart = -1
  let definitionStart = -1
  let result: string[] = []

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]!
    const trimmed = line.trim()

    // Look for JSDoc start before definition
    if (trimmed.startsWith("/**") && !inDefinition) {
      jsDocStart = i
    }

    // Look for interface/type declaration
    const defMatch = trimmed.match(new RegExp(`^export\\s+${keyword}\\s+${name}[<\\s=]`))
    if (defMatch && !inDefinition) {
      definitionStart = jsDocStart >= 0 ? jsDocStart : i
      inDefinition = true
    }

    if (inDefinition) {
      result.push(line)

      // Count braces to find definition end
      const openBraces = (line.match(/{/g) || []).length
      const closeBraces = (line.match(/}/g) || []).length
      braceCount += openBraces
      braceCount -= closeBraces

      if (openBraces > 0) {
        hasSeenOpenBrace = true
      }

      // Only check for end after we've seen the opening brace
      if (hasSeenOpenBrace && braceCount === 0) {
        // Include JSDoc if found before definition
        if (jsDocStart >= 0 && jsDocStart < definitionStart) {
          const jsDocLines = lines.slice(jsDocStart, definitionStart)
          return [...jsDocLines, ...result].join("\n")
        }
        return result.join("\n")
      }
    }

    // Reset JSDoc tracking if we hit a non-JSDoc, non-blank line before definition
    if (!inDefinition && jsDocStart >= 0 && !trimmed.startsWith("*") && !trimmed.startsWith("/**") && trimmed !== "") {
      if (!trimmed.startsWith(`export ${keyword}`)) {
        jsDocStart = -1
      }
    }
  }

  return null
}

/**
 * Read file and extract interface/type
 */
function processFile(typeName: string, source: TypeSource): InterfaceInfo | null {
  const fullPath = path.join(process.cwd(), source.file)

  if (!fs.existsSync(fullPath)) {
    console.warn(`Warning: Source file not found: ${source.file}`)
    return null
  }

  const sourceText = fs.readFileSync(fullPath, "utf-8")
  const extractName = source.extractName ?? typeName
  const definitionText = extractDefinition(sourceText, extractName, source.isType ?? false)

  if (!definitionText) {
    console.warn(
      `Warning: Could not extract ${source.isType ? "type" : "interface"} ${extractName} from ${source.file}`,
    )
    return null
  }

  return {
    name: typeName,
    sourceFile: source.file,
    fullText: definitionText,
  }
}

/**
 * Generate the full-interfaces.ts file
 */
function generateOutput(interfaces: InterfaceInfo[]): string {
  const entries = interfaces
    .map((iface) => {
      // Escape backticks and ${} in the interface text for template literal
      const escaped = iface.fullText.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")
      return `  ${iface.name}: \`${escaped}\``
    })
    .join(",\n\n")

  return `/**
 * Auto-generated full interface definitions.
 * Generated by scripts/extract-interfaces.ts
 * DO NOT EDIT MANUALLY
 */

export const FULL_INTERFACES: Record<string, string> = {
${entries}
}
`
}

// Main execution
function main() {
  console.log("Extracting interfaces from source files...")

  const interfaces: InterfaceInfo[] = []

  for (const [typeName, source] of Object.entries(TYPE_SOURCES)) {
    const info = processFile(typeName, source)
    if (info) {
      interfaces.push(info)
      console.log(`  ✓ ${typeName}`)
    } else {
      console.log(`  ✗ ${typeName} (skipped)`)
    }
  }

  const output = generateOutput(interfaces)
  const outputPath = path.join(process.cwd(), "src/cli/full-interfaces.ts")

  fs.writeFileSync(outputPath, output, "utf-8")
  console.log(`\nGenerated: ${outputPath}`)
  console.log(`Extracted ${interfaces.length} interfaces`)
}

main()

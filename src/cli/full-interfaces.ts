/**
 * Auto-generated full interface definitions.
 * Generated by scripts/extract-interfaces.ts
 * DO NOT EDIT MANUALLY
 */

export const FULL_INTERFACES: Record<string, string> = {
  Option: `export interface Option<T extends Type> extends Functype<T, "Some" | "None">, Promisable<T>, Doable<T>, Reshapeable<T> {
  /** The contained value (undefined for None) */
  readonly value: T | undefined
  /** Whether this Option contains no value */
  isEmpty: boolean
  /**
   * Returns true if this Option is a Some (contains a value)
   * @returns true if this Option contains a value, false otherwise
   */
  isSome(): this is Option<T> & { value: T; isEmpty: false }
  /**
   * Returns true if this Option is a None (contains no value)
   * @returns true if this Option is empty, false otherwise
   */
  isNone(): this is Option<T> & { value: undefined; isEmpty: true }
  /**
   * Returns the contained value or a default value if None
   * @param defaultValue - The value to return if this Option is None
   * @returns The contained value or defaultValue
   */
  orElse(defaultValue: T): T
  /**
   * Returns the contained value or throws an error if None
   * @param error - Optional custom error to throw. If not provided, throws a default error
   * @returns The contained value
   * @throws The specified error or a default error if the Option is None
   */
  orThrow(error?: Error): T
  /**
   * Returns this Option if it contains a value, otherwise returns the alternative container
   * @param alternative - The alternative Option to return if this is None
   * @returns This Option or the alternative
   */
  or(alternative: Option<T>): Option<T>
  /**
   * Returns the contained value or null if None
   * @returns The contained value or null
   */
  orNull(): T | null
  /**
   * Returns the contained value or undefined if None
   * @returns The contained value or undefined
   */
  orUndefined(): T | undefined
  /**
   * Maps the value inside the Option using the provided function
   * @param f - The mapping function
   * @returns A new Option containing the mapped value, or None if this Option is None
   */
  map<U extends Type>(f: (value: T) => U): Option<U>
  /**
   * Applies a wrapped function to a wrapped value (Applicative pattern)
   * @param ff - An Option containing a function from T to U
   * @returns A new Option containing the result of applying the function
   */
  ap<U extends Type>(ff: Option<(value: T) => U>): Option<U>
  /**
   * Returns this Option if it contains a value that satisfies the predicate, otherwise returns None
   * @param predicate - The predicate function to test the value
   * @returns This Option or None
   */
  filter(predicate: (value: T) => boolean): Option<T>
  /**
   * Maps the value using a function that returns an Option
   * @param f - The mapping function returning an Option
   * @returns The result of applying f to the contained value, or None if this Option is None
   */
  flatMap<U extends Type>(f: (value: T) => Option<U>): Option<U>
  /**
   * Maps the value using an async function that returns an Option
   * @param f - The async mapping function returning an Option
   * @returns Promise of the result of applying f to the contained value, or None if this Option is None
   */
  flatMapAsync<U extends Type>(f: (value: T) => Promise<Option<U>>): Promise<Option<U>>
  /**
   * Applies a binary operator to a start value and the contained value
   * @param f - The binary operator
   * @returns The result of the reduction
   */
  reduce<U>(f: (acc: U, value: T) => U): U
  /**
   * Applies a binary operator to the contained value and a start value
   * @param f - The binary operator
   * @returns The result of the reduction
   */
  reduceRight<U>(f: (acc: U, value: T) => U): U
  /**
   * Pattern matches over the Option, applying onNone if None and onSome if Some
   * @param onNone - Function to apply if the Option is None
   * @param onSome - Function to apply if the Option has a value
   * @returns The result of applying the appropriate function
   */
  fold<U>(onNone: () => U, onSome: (value: T) => U): U
  /**
   * Left-associative fold using the provided zero value and operation
   * @param z - Zero/identity value
   * @returns A function that takes an operation to apply
   */
  foldLeft<B>(z: B): (op: (b: B, a: T) => B) => B
  /**
   * Right-associative fold using the provided zero value and operation
   * @param z - Zero/identity value
   * @returns A function that takes an operation to apply
   */
  foldRight<B>(z: B): (op: (a: T, b: B) => B) => B
  /**
   * Converts this Option to a List
   * @returns A List containing the value if Some, or empty List if None
   */
  toList(): List<T>
  /**
   * Checks if this Option contains the specified value
   * @param value - The value to check for
   * @returns true if this Option contains the value, false otherwise
   */
  contains(value: T): boolean
  /** The number of elements in this Option (0 or 1) */
  size: number
  /**
   * Converts this Option to an Either
   * @param left - The value to use for Left if this Option is None
   * @returns Either.Right with the contained value if Some, or Either.Left with left if None
   */
  toEither<E>(left: E): Either<E, T>
  /**
   * Returns a string representation of this Option
   * @returns A string representation
   */
  toString(): string
  /**
   * Returns a simple object representation of this Option
   * @returns An object with _tag and value properties
   */
  toValue(): { _tag: "Some" | "None"; value: T }
  /**
   * Pattern matches over the Option, applying a handler function based on the variant
   * @param patterns - Object with handler functions for Some and None variants
   * @returns The result of applying the matching handler function
   */
  match<R>(patterns: { Some: (value: T) => R; None: () => R }): R
}`,

  Either: `export interface Either<L extends Type, R extends Type>
  extends FunctypeBase<R, "Left" | "Right">, Promisable<R>, Doable<R>, Reshapeable<R>, Extractable<R> {
  readonly _tag: "Left" | "Right"
  value: L | R
  isLeft(): this is Either<L, R> & { readonly _tag: "Left"; value: L }
  isRight(): this is Either<L, R> & { readonly _tag: "Right"; value: R }
  orElse: (defaultValue: R) => R
  orThrow: (error?: Error) => R
  or(alternative: Either<L, R>): Either<L, R>
  orNull: () => R | null
  orUndefined: () => R | undefined
  readonly map: <U extends Type>(f: (value: R) => U) => Either<L, U>
  ap: <U extends Type>(ff: Either<L, (value: R) => U>) => Either<L, U>
  merge: <L1 extends Type, R1 extends Type>(other: Either<L1, R1>) => Either<L | L1, [R, R1]>
  mapAsync: <U extends Type>(f: (value: R) => Promise<U>) => Promise<Either<L, U>>
  flatMap: <U extends Type>(f: (value: R) => Either<L, U>) => Either<L, U>
  flatMapAsync: <U extends Type>(f: (value: R) => Promise<Either<L, U>>) => Promise<Either<L, U>>
  toOption: () => Option<R>
  toList: () => List<R>
  toString: () => string
  [Symbol.iterator]: () => Iterator<R>
  yield: () => Generator<R, void, unknown>
  traverse: <U extends Type>(f: (value: R) => Either<L, U>) => Either<L, U[]>
  lazyMap: <U extends Type>(f: (value: R) => U) => Generator<Either<L, U>, void, unknown>
  tap: (f: (value: R) => void) => Either<L, R>
  tapLeft: (f: (value: L) => void) => Either<L, R>
  mapLeft: <L2 extends Type>(f: (value: L) => L2) => Either<L2, R>
  bimap: <L2 extends Type, R2 extends Type>(fl: (value: L) => L2, fr: (value: R) => R2) => Either<L2, R2>
  fold: <T extends Type>(onLeft: (value: L) => T, onRight: (value: R) => T) => T
  swap: () => Either<R, L>
  /**
   * Pipes the value through the provided function based on whether this is a Left or Right
   * @param onLeft - The function to apply if this is a Left
   * @param onRight - The function to apply if this is a Right
   * @returns The result of applying the appropriate function
   */
  pipeEither<U extends Type>(onLeft: (value: L) => U, onRight: (value: R) => U): U

  /**
   * Pipes the Either value through the provided function
   * @param f - The function to apply to the value (Left or Right)
   * @returns The result of applying the function to the value
   */
  pipe<U extends Type>(f: (value: L | R) => U): U
  /**
   * Pattern matches over the Either, applying a handler function based on the variant
   * @param patterns - Object with handler functions for Left and Right variants
   * @returns The result of applying the matching handler function
   */
  match<T>(patterns: { Left: (value: L) => T; Right: (value: R) => T }): T
  /**
   * Returns the value and tag for inspection
   */
  toValue(): { _tag: "Left" | "Right"; value: L | R }
  /**
   * Custom JSON serialization that excludes getter properties
   */
  toJSON(): { _tag: "Left" | "Right"; value: L | R }
}`,

  Try: `export interface Try<T>
  extends FunctypeBase<T, TypeNames>, Extractable<T>, Pipe<T>, Promisable<T>, Doable<T>, Reshapeable<T> {
  readonly _tag: TypeNames
  readonly error: Error | undefined
  isSuccess(): this is Try<T> & { readonly _tag: "Success"; error: undefined }
  isFailure(): this is Try<T> & { readonly _tag: "Failure"; error: Error }
  orElse: (defaultValue: T) => T
  orThrow: (error?: Error) => T
  or: (alternative: Try<T>) => Try<T>
  orNull: () => T | null
  orUndefined: () => T | undefined
  toOption: () => Option<T>
  toEither: <E extends Type>(leftValue: E) => Either<E, T>
  toList: () => List<T>
  toTry: () => Try<T>
  map: <U>(f: (value: T) => U) => Try<U>
  ap: <U>(ff: Try<(value: T) => U>) => Try<U>
  flatMap: <U>(f: (value: T) => Try<U>) => Try<U>
  flatMapAsync: <U>(f: (value: T) => Promise<Try<U>>) => Promise<Try<U>>
  /**
   * Pattern matches over the Try, applying onFailure if Failure and onSuccess if Success
   * @param onFailure - Function to apply if the Try is Failure
   * @param onSuccess - Function to apply if the Try is Success
   * @returns The result of applying the appropriate function
   */
  fold: <U extends Type>(onFailure: (error: Error) => U, onSuccess: (value: T) => U) => U
  toString: () => string
  /**
   * Pattern matches over the Try, applying a handler function based on the variant
   * @param patterns - Object with handler functions for Success and Failure variants
   * @returns The result of applying the matching handler function
   */
  match<R>(patterns: { Success: (value: T) => R; Failure: (error: Error) => R }): R
  toValue(): { _tag: TypeNames; value: T | Error }
}`,

  List: `export interface List<A> extends FunctypeCollection<A, "List">, Doable<A>, Reshapeable<A> {
  readonly length: number
  readonly [Symbol.iterator]: () => Iterator<A>
  // Override these to return List instead of FunctypeCollection
  map: <B>(f: (a: A) => B) => List<B>
  ap: <B>(ff: List<(value: A) => B>) => List<B>
  flatMap: <B>(f: (a: A) => Iterable<B>) => List<B>
  flatMapAsync: <B>(f: (a: A) => PromiseLike<Iterable<B>>) => PromiseLike<List<B>>
  // Override filter for type guard support
  filter<S extends A>(predicate: (a: A) => a is S): List<S>
  filter(predicate: (a: A) => unknown): List<A>
  filterNot: (p: (a: A) => boolean) => List<A>
  // List-specific methods
  /** @internal */
  filterType: <T extends Typeable<string, unknown>>(tag: string) => List<T & A>
  remove: (value: A) => List<A>
  removeAt: (index: number) => List<A>
  add: (item: A) => List<A>
  get: (index: number) => Option<A>
  concat: (other: List<A>) => List<A>
  take: (n: number) => List<A>
  takeWhile: (p: (a: A) => boolean) => List<A>
  takeRight: (n: number) => List<A>
  get last(): A | undefined
  get lastOption(): Option<A>
  get tail(): List<A>
  get init(): List<A>
  reverse: () => List<A>
  indexOf: (value: A) => number
  prepend: (item: A) => List<A>
  distinct: () => List<A>
  sorted: (compareFn?: (a: A, b: A) => number) => List<A>
  sortBy: <B>(f: (a: A) => B, compareFn?: (a: B, b: B) => number) => List<A>
  zip: <B>(other: List<B>) => List<[A, B]>
  zipWithIndex: () => List<[A, number]>
  groupBy: <K>(f: (a: A) => K) => globalThis.Map<K, List<A>>
  partition: (p: (a: A) => boolean) => [List<A>, List<A>]
  span: (p: (a: A) => boolean) => [List<A>, List<A>]
  slice: (start: number, end: number) => List<A>
  /**
   * Pattern matches over the List, applying a handler function based on whether it's empty
   * @param patterns - Object with handler functions for Empty and NonEmpty variants
   * @returns The result of applying the matching handler function
   */
  match<R>(patterns: { Empty: () => R; NonEmpty: (values: A[]) => R }): R
}`,

  Set: `export interface Set<A> extends FunctypeCollection<A, "Set">, Collection<A> {
  add: (value: A) => Set<A>
  remove: (value: A) => Set<A>
  contains: (value: A) => boolean
  has: (value: A) => boolean
  map: <B>(f: (a: A) => B) => Set<B>
  flatMap: <B>(f: (a: A) => Iterable<B>) => Set<B>
  filter: (p: (a: A) => boolean) => Set<A>
  filterNot: (p: (a: A) => boolean) => Set<A>
  fold: <U extends Type>(onEmpty: () => U, onValue: (value: A) => U) => U
  toList: () => List<A>
  toSet: () => Set<A>
  toArray: <B = A>() => B[]
  toString: () => string
}`,

  Map: `export interface Map<K, V>
  extends
    SafeTraversable<K, V>,
    Collection<Tuple<[K, V]>>,
    Typeable<"Map">,
    Serializable<[K, V][]>,
    Pipe<[K, V][]>,
    Foldable<Tuple<[K, V]>>,
    Iterable<[K, V]> {
  readonly _tag: "Map"
  add(item: Tuple<[K, V]>): Map<K, V>
  remove(value: K): Map<K, V>
  map<U>(f: (value: V) => U): Map<K, U>
  ap<U>(ff: Map<K, (value: V) => U>): Map<K, U>
  flatMap<K2, V2>(f: (entry: Tuple<[K, V]>) => Iterable<[K2, V2]>): Map<K2, V2>
  flatMapAsync<U>(f: (value: V) => PromiseLike<Map<K, U>>): PromiseLike<Map<K, U>>
  get(key: K): Option<V>
  getOrElse(key: K, defaultValue: V): V
  orElse(key: K, alternative: Option<V>): Option<V>
  fold<U extends Type>(onEmpty: () => U, onValue: (value: Tuple<[K, V]>) => U): U
  foldLeft<B>(z: B): (op: (b: B, a: Tuple<[K, V]>) => B) => B
  foldRight<B>(z: B): (op: (a: Tuple<[K, V]>, b: B) => B) => B
  /**
   * Pattern matches over the Map, applying a handler function based on whether it's empty
   * @param patterns - Object with handler functions for Empty and NonEmpty variants
   * @returns The result of applying the matching handler function
   */
  match<R>(patterns: { Empty: () => R; NonEmpty: (entries: Array<Tuple<[K, V]>>) => R }): R
  toValue(): { _tag: "Map"; value: [K, V][] }
}`,

  Lazy: `export interface Lazy<T extends Type> extends FunctypeBase<T, "Lazy">, Extractable<T>, Pipe<T> {
  /** Tag identifying this as a Lazy type */
  readonly _tag: "Lazy"
  /** Whether the computation has been evaluated */
  readonly isEvaluated: boolean
  /**
   * Returns the computed value or a default value if computation fails
   * @param defaultValue - The value to return if computation fails
   * @returns The computed value or defaultValue
   */
  orElse(defaultValue: T): T
  /**
   * Returns the computed value or null if computation fails
   * @returns The computed value or null
   */
  orNull(): T | null
  /**
   * Returns the computed value or throws an error if computation fails
   * @param error - Optional custom error to throw. If not provided, throws the computation error or a default error
   * @returns The computed value
   * @throws The specified error, computation error, or a default error
   */
  orThrow(error?: Error): T
  /**
   * Returns this Lazy if computation succeeds, otherwise returns the alternative Lazy
   * @param alternative - The alternative Lazy to use if computation fails
   * @returns This Lazy or the alternative
   */
  or(alternative: Lazy<T>): Lazy<T>
  /**
   * Maps the value inside the Lazy using the provided function
   * @param f - The mapping function
   * @returns A new Lazy containing the mapped value
   */
  map<U extends Type>(f: (value: T) => U): Lazy<U>
  /**
   * Applies a wrapped function to a wrapped value (Applicative pattern)
   * @param ff - A Lazy containing a function from T to U
   * @returns A new Lazy containing the result
   */
  ap<U extends Type>(ff: Lazy<(value: T) => U>): Lazy<U>
  /**
   * Maps the value inside the Lazy using an async function
   * @param f - The async mapping function
   * @returns A Promise of a new Lazy containing the mapped value
   */
  mapAsync<U extends Type>(f: (value: T) => Promise<U>): Promise<Lazy<U>>
  /**
   * Maps the value using a function that returns a Lazy
   * @param f - The mapping function returning a Lazy
   * @returns A new Lazy containing the flattened result
   */
  flatMap<U extends Type>(f: (value: T) => Lazy<U>): Lazy<U>
  /**
   * Maps the value using an async function that returns a Lazy
   * @param f - The async mapping function returning a Lazy
   * @returns A Promise of a new Lazy containing the flattened result
   */
  flatMapAsync<U extends Type>(f: (value: T) => Promise<Lazy<U>>): Promise<Lazy<U>>
  /**
   * Returns a Lazy that filters the value based on a predicate
   * @param predicate - The predicate function
   * @returns A Lazy containing an Option of the value
   */
  filter(predicate: (value: T) => boolean): Lazy<Option<T>>
  /**
   * Recovers from a failed computation by providing an alternative value
   * @param f - Function that takes the error and returns a recovery value
   * @returns A new Lazy that will use the recovery function if computation fails
   */
  recover(f: (error: unknown) => T): Lazy<T>
  /**
   * Recovers from a failed computation by providing an alternative Lazy
   * @param f - Function that takes the error and returns a recovery Lazy
   * @returns A new Lazy that will use the recovery Lazy if computation fails
   */
  recoverWith(f: (error: unknown) => Lazy<T>): Lazy<T>
  /**
   * Evaluates the computation and returns it as an Option
   * @returns Some containing the value if successful, None if computation fails
   */
  toOption(): Option<T>
  /**
   * Evaluates the computation and returns it as an Either
   * @returns Right containing the value if successful, Left containing the error if computation fails
   */
  toEither(): Either<unknown, T>
  /**
   * Evaluates the computation and returns it as an Either with a mapped error
   * @param mapError - Function to map the error
   * @returns Right containing the value if successful, Left containing the mapped error if computation fails
   */
  toEitherWith<E>(mapError: (error: unknown) => E): Either<E, T>
  /**
   * Evaluates the computation and returns it as a Try
   * @returns Try containing the result of the computation
   */
  toTry(): Try<T>
  /**
   * Applies an effect function to the value if computation succeeds
   * @param f - The effect function
   * @returns This Lazy for chaining
   */
  tap(f: (value: T) => void): Lazy<T>
  /**
   * Applies an effect function to the error if computation fails
   * @param f - The effect function for errors
   * @returns This Lazy for chaining
   */
  tapError(f: (error: unknown) => void): Lazy<T>
  /**
   * Pattern matching on the Lazy value
   * @param f - Function to apply to the computed value
   * @returns The result of applying f to the computed value
   */
  fold<U>(f: (value: T) => U): U
  /**
   * Pattern matching with success and failure handlers
   * @param onFailure - Function to handle computation failure
   * @param onSuccess - Function to handle successful computation
   * @returns The result of the appropriate handler
   */
  foldWith<U>(onFailure: (error: unknown) => U, onSuccess: (value: T) => U): U
  /**
   * Left fold operation
   * @param z - Initial value
   * @returns Function that takes an operator and applies it
   */
  foldLeft: <B>(z: B) => (op: (b: B, a: T) => B) => B
  /**
   * Right fold operation
   * @param z - Initial value
   * @returns Function that takes an operator and applies it
   */
  foldRight: <B>(z: B) => (op: (a: T, b: B) => B) => B
  /**
   * Pattern matching for the Lazy type
   * @param patterns - Object with handler for Lazy pattern
   * @returns The result of the matched handler
   */
  match<R>(patterns: { Lazy: (value: T) => R }): R
  /**
   * Creates a string representation of the Lazy
   * @returns String representation showing evaluation status
   */
  toString(): string
  /**
   * Converts the Lazy to a value object
   * @returns Object representation of the Lazy with evaluation state
   */
  toValue(): { _tag: "Lazy"; evaluated: boolean; value?: T }
}`,

  LazyList: `export interface LazyList<A extends Type>
  extends Foldable<A>, Pipe<LazyList<A>>, Serializable<LazyList<A>>, Typeable<"LazyList"> {
  // Iterator protocol
  [Symbol.iterator](): Iterator<A>

  // Lazy operations
  map<B extends Type>(f: (a: A) => B): LazyList<B>
  flatMap<B extends Type>(f: (a: A) => LazyList<B>): LazyList<B>
  filter(predicate: (a: A) => boolean): LazyList<A>
  take(n: number): LazyList<A>
  drop(n: number): LazyList<A>
  takeWhile(predicate: (a: A) => boolean): LazyList<A>
  dropWhile(predicate: (a: A) => boolean): LazyList<A>
  concat(other: LazyList<A>): LazyList<A>
  zip<B extends Type>(other: LazyList<B>): LazyList<[A, B]>

  takeRight(n: number): LazyList<A>
  reverse(): LazyList<A>
  distinct(): LazyList<A>
  zipWithIndex(): LazyList<[A, number]>

  // Element access (properties)
  get head(): A | undefined
  get headOption(): Option<A>
  get last(): A | undefined
  get lastOption(): Option<A>
  get tail(): LazyList<A>
  get init(): LazyList<A>

  // Terminal operations (force evaluation)
  toList(): List<A>
  toArray(): A[]
  forEach(f: (a: A) => void): void
  reduce<B extends Type>(f: (acc: B, a: A) => B, initial: B): B
  find(predicate: (a: A) => boolean): Option<A>
  some(predicate: (a: A) => boolean): boolean
  every(predicate: (a: A) => boolean): boolean
  count(): number

  // Additional methods for clarity
  toString(): string
}`,

  TaskOutcome: `export interface TaskOutcome<T>
  extends FunctypeBase<T, "Ok" | "Err">, Extractable<T>, AsyncMonad<T>, Promisable<T>, Doable<T> {
  readonly _tag: "Ok" | "Err"
  readonly _meta: TaskMetadata

  // Value access
  readonly value?: T
  readonly error?: Throwable

  // Functional methods
  readonly map: <U>(f: (value: T) => U) => TaskOutcome<U>
  readonly flatMap: <U>(f: (value: T) => TaskOutcome<U> | Either<Throwable, U>) => TaskOutcome<U>
  readonly ap: <U>(ff: TaskOutcome<(value: T) => U>) => TaskOutcome<U>
  readonly mapAsync: <U>(f: (value: T) => Promise<U>) => Promise<TaskOutcome<U>>
  readonly flatMapAsync: <U>(f: (value: T) => Promise<TaskOutcome<U>>) => Promise<TaskOutcome<U>>

  // Error handling methods
  readonly mapError: (f: (error: Throwable) => Throwable) => TaskOutcome<T>
  readonly recover: (value: T) => Ok<T>
  readonly recoverWith: (f: (error: Throwable) => T) => Ok<T>

  // Type guards
  readonly isSuccess: () => this is Ok<T>
  readonly isFailure: () => this is Err<T>
  readonly isOk: () => this is Ok<T>
  readonly isErr: () => this is Err<T>

  // Conversion methods
  readonly toEither: () => Either<Throwable, T>
  readonly toTry: () => Try<T>
  readonly toOption: () => Option<T>
  readonly toList: () => List<T>

  // Pattern matching
  readonly fold: <U>(onErr: (error: Throwable) => U, onOk: (value: T) => U) => U
  readonly match: <U>(patterns: { Ok: (value: T) => U; Err: (error: Throwable) => U }) => U
}`,

  Tuple: `export interface Tuple<T extends Type[]>
  extends Foldable<T[number]>, Pipe<Tuple<T>>, Serializable<Tuple<T>>, Typeable<"Tuple"> {
  get<K extends number>(index: K): T[K]

  map<U extends Type[]>(f: (value: T) => U): Tuple<U>

  flatMap<U extends Type[]>(f: (value: T) => Tuple<U>): Tuple<U>

  toArray(): T

  length: number

  [Symbol.iterator](): Iterator<T[number]>

  toString(): string

  toValue(): { _tag: "Tuple"; value: T }
}`,

  Stack: `export type Stack<A extends Type> = {
  /**
   * Push a value onto the top of the stack
   * @param value - The value to push
   * @returns A new Stack with the value added
   */
  push(value: A): Stack<A>

  /**
   * Remove and return the top value from the stack
   * @returns A tuple containing the new Stack and the value
   */
  pop(): [Stack<A>, Option<A>]

  /**
   * Return the top value without removing it
   * @returns The top value wrapped in an Option
   */
  peek(): Option<A>

  /**
   * Transforms each element in the stack using the provided function
   * @param f - The mapping function
   * @returns A new Stack with transformed elements
   */
  map<B extends Type>(f: (a: A) => B): Stack<B>

  /**
   * Maps each element to a Stack and flattens the result
   * @param f - The mapping function returning a Stack
   * @returns A new flattened Stack
   */
  flatMap<B extends Type>(f: (a: A) => Stack<B>): Stack<B>

  /**
   * Applies a Stack of functions to this Stack
   * @param ff - Stack of functions to apply
   * @returns A new Stack with applied functions
   */
  ap<B extends Type>(ff: Stack<(value: A) => B>): Stack<B>

  /**
   * Maps each element to an async Stack and flattens the result
   * @param f - The async mapping function returning a Stack
   * @returns A promise of the new flattened Stack
   */
  flatMapAsync<B extends Type>(f: (value: A) => PromiseLike<Stack<B>>): PromiseLike<Stack<B>>

  /**
   * Convert the stack to a List
   * @returns A List containing all elements
   */
  toList(): List<A>

  /**
   * Convert the stack to an array
   * @returns An array of all elements
   */
  toArray(): A[]

  /**
   * Returns a string representation of the stack
   * @returns A string representation
   */
  toString(): string

  /**
   * Pattern matches over the Stack, applying a handler function based on whether it's empty
   * @param patterns - Object with handler functions for Empty and NonEmpty variants
   * @returns The result of applying the matching handler function
   */
  match<R>(patterns: { Empty: () => R; NonEmpty: (values: A[]) => R }): R
} & Traversable<A> &`
}

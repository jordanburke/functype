{
  "module": "Brand",
  "description": "True phantom types for TypeScript - compile-time type safety with zero runtime overhead",
  "category": "Utility",
  "keyMethods": [],
  "staticMethods": [
    {
      "name": "Brand",
      "description": "Create a phantom-typed value (returns the primitive directly)",
      "signature": "Brand<K, T>(brand: K, value: T): Brand<K, T>",
      "example": "const userId = Brand('UserId', 'user-123') // userId IS 'user-123'"
    },
    {
      "name": "unbrand",
      "description": "Utility function for compatibility (rarely needed since branded values ARE primitives)",
      "signature": "unbrand<K, T>(branded: Brand<K, T>): T",
      "example": "const raw = unbrand(userId) // 'user-123'"
    },
    {
      "name": "BrandedString",
      "description": "Factory for creating string branded type constructors",
      "signature": "BrandedString<K>(brand: K): (value: string) => Brand<K, string>",
      "example": "const createUserId = BrandedString('UserId')"
    },
    {
      "name": "BrandedNumber",
      "description": "Factory for creating number branded type constructors",
      "signature": "BrandedNumber<K>(brand: K): (value: number) => Brand<K, number>",
      "example": "const createAge = BrandedNumber('Age')"
    },
    {
      "name": "BrandedBoolean",
      "description": "Factory for creating boolean branded type constructors",
      "signature": "BrandedBoolean<K>(brand: K): (value: boolean) => Brand<K, boolean>",
      "example": "const createIsActive = BrandedBoolean('IsActive')"
    }
  ],
  "typeUtilities": [
    {
      "name": "Brand<K, T>",
      "description": "Phantom type brand - exists only at compile time",
      "example": "type UserId = Brand<'UserId', string>"
    },
    {
      "name": "Unbrand<T>",
      "description": "Extract the underlying type from a branded type",
      "example": "type RawUserId = Unbrand<UserId> // string"
    },
    {
      "name": "ExtractBrand<T>",
      "description": "Extract the brand identifier from a branded type",
      "example": "type UserBrand = ExtractBrand<UserId> // 'UserId'"
    }
  ],
  "commonPatterns": [
    {
      "name": "Basic Branding",
      "description": "Create phantom types - branded values ARE their primitives",
      "code": "type UserId = Brand<'UserId', string>\nconst userId = Brand('UserId', 'user-123')\nconsole.log(userId) // 'user-123' - it IS a string!\nconsole.log(typeof userId) // 'string'"
    },
    {
      "name": "Type Safety",
      "description": "Use branded types in functions - no unwrapping needed",
      "code": "function getUserProfile(id: UserId): string {\n  return `Profile: ${id}` // id IS a string!\n}\n// getUserProfile('user-123') // Error!\ngetUserProfile(userId) // Works!"
    },
    {
      "name": "Direct Usage",
      "description": "Branded values work everywhere primitives are expected",
      "code": "const userId = Brand('UserId', 'user-123')\n// All string operations work directly\nuserId.toUpperCase() // 'USER-123'\nuserId.length // 8\n`ID: ${userId}` // 'ID: user-123'\nJSON.stringify({ userId }) // '{\"userId\":\"user-123\"}'"
    }
  ],
  "relatedTypes": ["ValidatedBrand"],
  "seeAlso": ["ValidatedBrand for runtime validation", "Functype design patterns for type safety"]
}
